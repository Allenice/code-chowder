<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
        body {
            background: #efefef;
            padding: 0;
            margin: 0;
        }

        .canvas-wrap {
            width: 488px;
            height: 400px;
            display: block;
            box-shadow: 0 0 3px rgba(0,0,0, .3);
            margin: 10px auto;
            border-radius: 3px;
            background: #fff;
        }
    </style>
</head>
<body>
    <div class="canvas-wrap">
        <canvas id="canvas1" width="488" height="400"></canvas>
    </div>

    <script src="../Chart.js-2.3.0/dist/Chart.js"></script>
    <script>
    (function(){
        'use strict';

        const PI = Math.PI;
        var ctx = document.getElementById('canvas1').getContext('2d');
        var helpers = Chart.helpers;

        var data = {
            labels: ['洗剪吹', '烫染', '护理', '其他'],
            datasets: [
                {
                    data: [1, 2, 3, 4],
                    hoverBorderColor: '#fff',
                    backgroundColor: ['#6AA3FF', '#BD7EFF', '#FF7CA2', '#FFDB53']
                }
            ]
        };

        var fontSize = 14;

        Chart.defaults.zoomDoughnut = Chart.helpers.clone(Chart.defaults.doughnut);
        Chart.controllers.zoomDoughnut = Chart.controllers.doughnut.extend({
            draw: function(ease) {
                var elements = this.getMeta().data;

                // hover 时候放大
                elements.forEach(function(arc) {
                    arc._zoom = arc._zoom || 1;
                    arc._view.outerRadius = arc._model.outerRadius = 140 * (1 + (arc._zoom - 1) * ease);
                    arc._view.innerRadius = arc._model.innerRadius = 40;
                });

                // 调用原来的 draw 把圆环画出来
                Chart.controllers.doughnut.prototype.draw.apply(this, arguments);

                // 之前放大的还原原来的大小，防止 label 也跟着放大
                elements.forEach(function(arc) {
                    arc._view.outerRadius = arc._model.outerRadius = 140;
                });

                this._afterDraw(elements, ease);

            },

            _afterDraw: function(elements, ease) {
                var _this = this,
                    ctx = this.chart.chart.ctx,
                    data = this.chart.data,
                    total = this.getMeta().total,
                    totalPercent = 0,
                    metaData = []
                ;

                // 计算百分比
                elements.forEach(function(arc, i) {
                    var label = data.labels[arc._index];
                    var dataset = data.datasets[arc._datasetIndex];
                    var d = parseInt(dataset.data[arc._index]);
                    var p = parseFloat((d / total * 100).toFixed(1));

                    if (dataset.percentages && dataset.percentages[arc._index]) {
                        p = parseFloat(dataset.percentages[arc._index]);
                    }

                    // 百分比总和不是 100% 的话，凑成 100%
                    totalPercent += p;
                    if (i >= elements.length - 1 && p != 100) {
                        p += (100 - totalPercent);
                    }

                    p = p.toFixed(1);

                    metaData.push({
                        vm: arc._view,
                        label: label,
                        percentage: parseFloat(p)
                    });
                    
                });

                // 画 label
                var labelMeta;
                metaData.forEach(function(m, i) {
                    ctx = _this.chart.chart.ctx;
                    labelMeta = _this._getLabelMeta(ctx, m.vm, m.label, m.percentage, labelMeta);

                    _this._drawLabel(ctx, labelMeta);
                    
                });

            },

            // 获取 Label 相关信息
            _getLabelMeta: function(ctx, vm, label, percentage, prevMeta) {
                var _this = this,
                    text = label + ' ' + percentage + '%',
                    textWidth = ctx.measureText(text).width,
                    chartWidth = this.chart.chart.width,
                    sA = vm.startAngle,
                    eA = vm.endAngle,
                    cA,
                    isLeft = true,
                    isTop = true,
                    splitA = PI * 1/6,
                    splitCount = Math.ceil(vm.circumference / splitA) + 1,

                    step = (eA - sA) / splitCount,
                    point1 = {},
                    point2 = {},
                    point3 = {}
                ;

                var textX, r, x, y, xSign = 1, ySign = 1;

                ctx.save();

                ctx.textBaseline = 'middle';
                ctx.font = fontSize + 'px';

                // 查找文字不会被遮住的点
                for (var i = 1; i < splitCount; i++) {
                    var find = false;

                    cA = (step * i) + sA;
                    isLeft = Math.abs(cA) >= 1/2 * PI;
                    isTop = (cA >= -0.5*PI && cA <= 0) || (cA > PI && cA < 1.5 * PI);

                    r = vm.outerRadius - 25;
                    x = vm.x + r * Math.cos(cA);
                    y = vm.y + r * Math.sin(cA);

                    xSign = isLeft ? -1 : 1;
                    ySign = isTop ? -1 : 1;

                    // 计算折线的三个点
                    point1.x = x + 2 * xSign;
                    point1.y = y + 2 * ySign;

                    [1/4, 1/8, 3/8].forEach(function(rotateA) {
                        if (find) return false;
                        
                        point2.x = point1.x + 40 * Math.cos(rotateA * PI) * xSign;
                        point2.y = point1.y + 40 * Math.sin(rotateA * PI) * ySign;

                        point3.x = point2.x + 20 * xSign;
                        point3.y = point2.y;

                        // 判断文字是否超出边界或者重叠
                        let _x;
                        textX = isLeft ? point3.x - 10 : point3.x + 10;
                        _x = textX + textWidth * xSign;

                        if (_x > 0 && _x < chartWidth) {
                            if (!prevMeta) {
                                find = true;
                            } else {
                                let rect1 = {
                                    x: isLeft ? textX : textX - textWidth,
                                    y: point3.y - fontSize/2,
                                    height: fontSize,
                                    width: textWidth
                                }

                                let rect2 = {
                                    x: isLeft ? prevMeta.textPos.x : prevMeta.textPos.x - textWidth,
                                    y: prevMeta.textPos.y - fontSize/2,
                                    height: fontSize,
                                    width: prevMeta.textWidth
                                }

                                // 判断文字是否重叠
                                if (!_this._isCollide(rect1, rect2)) {
                                    find = true;
                                }
                            }
                        }
                    });

                    if (find) {
                        break;
                    }

                    
                }

                ctx.restore();

                return {
                    text: text,
                    textWidth: textWidth,
                    isTop: isTop,
                    isLeft: isLeft,
                    point1: point1,
                    point2: point2,
                    point3: point3,
                    textPos: {
                        x: textX,
                        y: point3.y
                    },
                    x: x,
                    y: y
                }
            },

            // 是否重叠
            _isCollide: function(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.height + rect1.y > rect2.y
            },

            _drawLabel: function(ctx, metaData) {
                ctx.save();

                ctx.textBaseline = 'middle';
                ctx.font = fontSize + 'px';

                // 画白色的点
                ctx.beginPath();
                ctx.fillStyle = '#fff';
                ctx.arc(metaData.x, metaData.y, 3, 0, 2 * PI);
                ctx.fill();

                // 画折线
                ctx.beginPath();
                ctx.moveTo(metaData.point1.x, metaData.point1.y);
                ctx.lineTo(metaData.point2.x, metaData.point2.y);
                ctx.lineTo(metaData.point3.x, metaData.point3.y);
                ctx.strokeStyle = '#A1C5FF';
                ctx.stroke();

                // 在第三个点画点
                ctx.beginPath();
                ctx.fillStyle = '#A1C5FF';
                ctx.arc(metaData.point3.x, metaData.point3.y, 3, 0, 2 * PI);
                ctx.fill();

                // 画文字
                ctx.fillStyle = '#333';
                ctx.textAlign = metaData.isLeft ? 'right' : 'left';
                
                ctx.fillText(metaData.text, metaData.textPos.x, metaData.textPos.y);

                ctx.restore();

            },

        });

        var chart = new Chart(ctx, {
            type: 'zoomDoughnut',
            data: data,
            options: {
                tooltips: {
                    enabled: false
                },
                hover: {
                    onHover: function(elements) {
                        if (this.lastActive.length > 0) {
                            this.lastActive.forEach(function(el){ el._zoom = 1; });
                        }

                        if (elements.length > 0) {
                            elements.forEach(function(el) {el._zoom = 1.072;});
                        }
                    }
                },
                legend: {
                    display: false
                },

                cutoutPercentage: 30,
            }
            
        });

        // setInterval(function() {
        //     var data = [];
        //     for (var i = 0; i < 4; i++) {
        //         data.push(parseInt(Math.random() * 100));
        //     }
        //     chart.data.datasets[0].data = data;
        //     chart.update();
        //     // console.log(data);
        // }, 3000);
    })();
    </script>
</body>
</html>